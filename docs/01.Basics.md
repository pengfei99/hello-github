# 1 Gitup basics

## 1.1 Setup git

Go to the project folder that you want to do version control with git, and do below command

```shell
git init
```

This will create **.git** directory in your project, all the information that help you to do version control will be 
located here.

## 1.2 Create a commit

Create a file called test/doc1.txt, and put below text in it 
```text
hello this is my first commit
```

Then commit a new version. Each time you call commit, a new version will be created.
```shell
# track the changes of this file
git add test/doc1.txt

# commit a version
git commit -m "add doc1.txt version1"
```

Now change the file, add below line. Then commit the changes again

``` text
update to version 2
```

```shell
# track the changes of this file
git add test/doc1.txt

# commit a version
git commit -m "update doc1.txt to version2"
```

## 1.3 Go back/forward to a version

Now we have two versions of a file, suppose we have made some mistakes in version 2, and we want to go back to version 1.

We first need to know which version is available

```shell
git log 

```
you should see below outputs. it has all the information of every version that you have committed.
- commit id : unique identifier of a commit
- Author : 
- Date
- Description
```text
commit 02e34c31ac224bac5f6753883c12b0013daff00a (HEAD -> main)
Author: Pengfei Liu <liu.pengfei@hotmail.fr>
Date:   Thu Mar 24 19:39:18 2022 +0100

    update doc1.txt to version2

commit d8d70adfa1490fdc5824b47d75cb8c3d9cf51fea
Author: Pengfei Liu <liu.pengfei@hotmail.fr>
Date:   Thu Mar 24 19:38:41 2022 +0100

    add doc1.txt version1

```

If you want information more compact, you can all a oneline log

```shell
git log --pretty=oneline

```
You should see this:

```text
02e34c31ac224bac5f6753883c12b0013daff00a (HEAD -> main) update doc1.txt to version2
d8d70adfa1490fdc5824b47d75cb8c3d9cf51fea add doc1.txt version1
```

If you have a visualization tool, you can view the commit are line up as a timeline based on the commit time. You can
notice that **the last commit has (HEAD -> main)** which means this commit is the head (most recent) commit of branch
main. We will talk about branch later. Now lets just go back to version 1. Run below command:

```shell
# this command means set head of this branch to the version before last version 
git reset --hard HEAD^
```

After running this command, you can notice **in file doc1.txt, the line 'update to version 2' has been removed**. It means
we are going back to version 1. And the below log confirms it. We don't have the version 2 in the timeline.  

```shell
$ git log --pretty=oneline
d8d70adfa1490fdc5824b47d75cb8c3d9cf51fea (HEAD -> main) add doc1.txt version1

```

Now suppose I regret, I want to restore version2. Don't worry, nothing is lost, you can still get it back, all you need
to do is **get the commit id of version 2**. If your terminal is not closed, you can easily get the commit id of version 2.

Now suppose you closed your terminal, you can still get it via below command:

```shell
# git track all user's action, you can get your action history with below command
git reflog
```

You should see below output:
```shell
d8d70ad (HEAD -> main) HEAD@{0}: reset: moving to HEAD^
02e34c3 HEAD@{1}: commit: update doc1.txt to version2
d8d70ad (HEAD -> main) HEAD@{2}: commit: add doc1.txt version1
```
We can get the commit id of version 2 is "02e34c3". Note it's not the complete version id, but don't worry git will 
autocomplete it for you.

Let's rerun 

```shell
git reset --hard d8d70ad
```

Now the verion 2 is back, you can confirm it from the log

```shell
$ git log --pretty=oneline
02e34c31ac224bac5f6753883c12b0013daff00a (HEAD -> main) update doc1.txt to version2
d8d70adfa1490fdc5824b47d75cb8c3d9cf51fea add doc1.txt version1

```

There are two ways to set head 
1. Use relative HEAD indicator: HEAD^ means the 1st version before head. HEAD^^ means the 2nd version before head. For 
                                the 100st version before head, you can write HEAD~100.

2. Use commit id: git reset --hard d8d70ad 

## 1.4 Staging area

When you create a version of your project in git, it has two steps:
1. Add changes from working directory to staging area (i.e. git add)
2. Commit all the changes of staging area to the current branch (i.e. git commit)

Below figure shows an example

Let's create a 3rd version, and review the process.

Add below line to 'doc1.txt'

```text
update to version 3
```

Then run below command

```shell
# This shows the current status of your project file tracking 
git status
```

You should see 
```text
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   test/doc1.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        .idea/
        docs/

```

Now run:

```shell
git add test/doc1.txt
git status
```

Now you should see:

```text
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   test/doc1.txt

```

Now run:

```shell
git commit -m "update test/doc1.txt to version 3"
```

You should see
```text
On branch main

nothing to commit, working tree clean
```